install.packages(c("binaryLogic", "dplyr", "ggplot2", "jsonlite", "magrittr", "optional", "purrr", "reshape2", "rlist", "stringr", "tidyr"))
source('~/GitHub/DeepMetaMorph/data_analysis/Script.R')
library(purrr)
library(magrittr)
library(optional)
library(dplyr)
library(reshape2)
library(ggplot2)
library(jsonlite)
library(binaryLogic)
library(stringr)
library(tidyr)
library(rlist)
data_path = "../extracted/"
data_analysis[["export"]] <- function(export_stack = TRUE, export_mode = "seq2seq") {
print(strrep("-", 50))
print("Freeing memory...")
all_instructions <<- NA
all_sequences <<- NA
json <<- NA
gc()
print("Tidying input...")
print("- Select")
if (export_mode == "statediff") {
X <- df %>% select(Sequence, StateDiff)
} else {
X <- df %>% select(Sequence, StateBefore, StateAfter)
}
df <<- NA
gc()
print("- Group By")
X <- X %>% group_by(Sequence)
print("- Mutate")
X <- X %>% mutate(InstructionIndex = row_number())
print("- Ungroup")
X <- X %>% ungroup()
print("- Pad sequences")
if (export_mode == "seq2seq") {
X_padded <- X %>% select(Sequence, InstructionIndex)
X_padded$State <- X$StateBefore
l <- l + 1
} else if (export_mode == "statediff") {
X_padded <- data.frame(X)
}
for (i in 1:m) {
if (i %% (m%/%100) == 0) {
print(paste0(i %/% (m%/%100), "%"))
}
seq_l <- seq_lengths[[i]]
if (seq_l < l) {
to_pad <- l - seq_l
pad <- data.frame(matrix(NA, nrow=to_pad, ncol=3))
names(pad) <- names(X_padded)
pad[["Sequence"]] <- rep(i,to_pad)
if (export_mode == "statediff") {
pad[["StateDiff"]] <- rep(list(rep(-1, n)), to_pad)
}
else if (export_mode == "seq2seq") {
final_state <- X %>% filter(Sequence == i & InstructionIndex == seq_l)
rep(list(rep(-1, n)), to_pad-1)
pad[["State"]] <- c(list(final_state$StateAfter[[1]]),rep(list(rep(-1, n)), to_pad-1))
}
pad[["InstructionIndex"]] <- (seq_l+1):l
X_padded <- rbind(X_padded, pad)
}
}
print("- Arrange")
X_padded <- X_padded %>% arrange(Sequence, InstructionIndex)
return(X_padded)
print("- Bind")
if (export_mode == "statediff") {
X_mat <- do.call(rbind, X_padded$StateDiff)
} else {
X_mat <- do.call(rbind, X_padded$State)
}
print("Exporting input...")
write.csv(X_mat, file=gzfile("input.csv.gz", compression = 1), row.names = FALSE)
print("Tidying output...")
inst_and_args <- unique(paste(df$Instruction, df$Arguments))
print("- Mutate")
Y <- df %>% mutate(InstAndArgs = paste(Instruction, Arguments))
print("- Group By")
Y <- Y %>% group_by(Sequence)
print("- Mutate")
Y <- Y %>% mutate(InstructionIndex = row_number())
print("- Ungroup")
Y <- Y %>% ungroup()
print("- Select")
Y <- Y %>% select(Sequence, InstructionIndex, InstAndArgs)
print("- Pad sequences & add <GO> & <NOP> tokens")
# Sequence are 2 step longer including an <GO> and an <NOP> token
l <- l + 2
Y_padded <- rep(NA, seq_count*l)
for (i in 1:m) {
if (i %% (m%/%100) == 0) {
print(paste0(i %/% (m%/%100), "%"))
}
seq_l <- seq_lengths[[i]]
to_pad <- l - seq_l - 1
index_start <- ((i-1)*l+1)
index_end <- (i*l)
Y_padded[index_start] <- "<GO>"
if (length(Y[Y$Sequence == i,]$InstAndArgs) == 0) {
print(Y[Y$Sequence == i,]$InstAndArgs)
print(i)
print(seq_l)
}
Y_padded[(index_start+1):(index_start+seq_l)] <- Y[Y$Sequence == i,]$InstAndArgs
Y_padded[(index_start+seq_l+1):index_end] <- rep("<NOP>", to_pad)
}
print("Exporting categorical output...")
write.csv(Y_padded, file=gzfile("output.categorical.csv.gz", compression = 1), row.names = FALSE)
# Creating dictionnary
dict <- sort(unique(Y_padded))
print("Exporting dictionary...")
write.csv(dict, file=gzfile("dict.csv.gz", compression = 1), row.names = FALSE)
print("- Exporting dimensions...")
n_y <- length(dict)
dims <- data.frame(m, l, l, n, n_y)
colnames(dims) <- c("m", "T_x", "T_y", "n_x", "n_y")
write.csv(dims, file=gzfile("dimensions.csv.gz", compression = 1), row.names = FALSE)
print(">>>> All done. <<<<")
print(strrep("-", 50))
}
data_analysis[["help"]] <- function() {
print("You can use `data_analysis` object to see various statistics")
print("  * `data_analysis[['histogram']]()` to view the histogram of instructions")
print("  * `data_analysis[['instruction']](inst)` to start analysing the instruction 'inst' (NASM format)")
print("  * `data_analysis[['heatmap_global']]()` to view the heatmap of the processor state for all the instructions")
print("  * `data_analysis[['statistics']]()` to display various useful statistics")
print("  * `data_analysis[['export']]()` to export the data for the model")
print("  * `data_analysis[['help']]()` to display this message again. ")
}
data_analysis[["help"]]()
data_analysis[['export']]()
data_analysis[['export']]()
library(purrr)
library(magrittr)
library(optional)
library(dplyr)
library(reshape2)
library(ggplot2)
library(jsonlite)
library(binaryLogic)
library(stringr)
library(tidyr)
library(rlist)
data_analysis[['export']]()
# ------ EXPORT ------
# Exports a 3-columns table (input), to input.csv
# - 1st column is the sequence index
# - 2nd column is the instruction index within the sequence
# - 3rd column are the parameters values (machine state before the instruction)
#
# Exports a 3-column table (output), to output.csv
# - 1st column is the sequence index
# - 2nd column is the instruction index within the sequence
# - 3rd column is the index (one hot) of the right instruction to use.
#
# Export mode 'seq2seq' exports every machine state from the start to the end of the sequence
# Export mode 'global' exports only the first and the last machine state of the sequence
# Export mode 'statediff' exports all the state diffs from the start to the end instead of machine states
data_analysis[["export"]] <- function(export_stack = TRUE, export_mode = "seq2seq") {
print(strrep("-", 50))
print("Freeing memory...")
all_instructions <<- NA
all_sequences <<- NA
json <<- NA
gc()
print("Tidying input...")
print("- Select")
if (export_mode == "statediff") {
X <- df %>% select(Sequence, StateDiff)
} else {
X <- df %>% select(Sequence, StateBefore, StateAfter)
}
df <<- NA
gc()
print("- Group By")
X <- X %>% group_by(Sequence)
print("- Mutate")
X <- X %>% mutate(InstructionIndex = row_number())
print("- Ungroup")
X <- X %>% ungroup()
print("- Pad sequences")
if (export_mode == "seq2seq") {
X_padded <- X %>% select(Sequence, InstructionIndex)
X_padded$State <- X$StateBefore
l <- l + 1
} else if (export_mode == "statediff") {
X_padded <- data.frame(X)
}
for (i in 1:m) {
if (i %% (m%/%100) == 0) {
print(paste0(i %/% (m%/%100), "%"))
}
seq_l <- seq_lengths[[i]]
if (seq_l < l) {
to_pad <- l - seq_l
pad <- data.frame(matrix(NA, nrow=to_pad, ncol=3))
names(pad) <- names(X_padded)
pad[["Sequence"]] <- rep(i,to_pad)
if (export_mode == "statediff") {
pad[["StateDiff"]] <- rep(list(rep(-1, n)), to_pad)
}
else if (export_mode == "seq2seq") {
final_state <- X %>% filter(Sequence == i & InstructionIndex == seq_l)
rep(list(rep(-1, n)), to_pad-1)
pad[["State"]] <- c(list(final_state$StateAfter[[1]]),rep(list(rep(-1, n)), to_pad-1))
}
pad[["InstructionIndex"]] <- (seq_l+1):l
X_padded <- rbind(X_padded, pad)
}
}
print("- Arrange")
X_padded <- X_padded %>% arrange(Sequence, InstructionIndex)
print("- Bind")
if (export_mode == "statediff") {
X_mat <- do.call(rbind, X_padded$StateDiff)
} else {
X_mat <- do.call(rbind, X_padded$State)
}
print("Exporting input...")
write.csv(X_mat, file=gzfile("input.csv.gz", compression = 1), row.names = FALSE)
print("Tidying output...")
inst_and_args <- unique(paste(df$Instruction, df$Arguments))
print("- Mutate")
Y <- df %>% mutate(InstAndArgs = paste(Instruction, Arguments))
print("- Group By")
Y <- Y %>% group_by(Sequence)
print("- Mutate")
Y <- Y %>% mutate(InstructionIndex = row_number())
print("- Ungroup")
Y <- Y %>% ungroup()
print("- Select")
Y <- Y %>% select(Sequence, InstructionIndex, InstAndArgs)
print("- Pad sequences & add <GO> & <NOP> tokens")
# Sequence are 2 step longer including an <GO> and an <NOP> token
l <- l + 2
Y_padded <- rep(NA, seq_count*l)
for (i in 1:m) {
if (i %% (m%/%100) == 0) {
print(paste0(i %/% (m%/%100), "%"))
}
seq_l <- seq_lengths[[i]]
to_pad <- l - seq_l - 1
index_start <- ((i-1)*l+1)
index_end <- (i*l)
Y_padded[index_start] <- "<GO>"
if (length(Y[Y$Sequence == i,]$InstAndArgs) == 0) {
print(Y[Y$Sequence == i,]$InstAndArgs)
print(i)
print(seq_l)
}
Y_padded[(index_start+1):(index_start+seq_l)] <- Y[Y$Sequence == i,]$InstAndArgs
Y_padded[(index_start+seq_l+1):index_end] <- rep("<NOP>", to_pad)
}
print("Exporting categorical output...")
write.csv(Y_padded, file=gzfile("output.categorical.csv.gz", compression = 1), row.names = FALSE)
# Creating dictionnary
dict <- sort(unique(Y_padded))
print("Exporting dictionary...")
write.csv(dict, file=gzfile("dict.csv.gz", compression = 1), row.names = FALSE)
print("- Exporting dimensions...")
n_y <- length(dict)
dims <- data.frame(m, l, l, n, n_y)
colnames(dims) <- c("m", "T_x", "T_y", "n_x", "n_y")
write.csv(dims, file=gzfile("dimensions.csv.gz", compression = 1), row.names = FALSE)
print(">>>> All done. <<<<")
print(strrep("-", 50))
}
data_analysis[["help"]] <- function() {
print("You can use `data_analysis` object to see various statistics")
print("  * `data_analysis[['histogram']]()` to view the histogram of instructions")
print("  * `data_analysis[['instruction']](inst)` to start analysing the instruction 'inst' (NASM format)")
print("  * `data_analysis[['heatmap_global']]()` to view the heatmap of the processor state for all the instructions")
print("  * `data_analysis[['statistics']]()` to display various useful statistics")
print("  * `data_analysis[['export']]()` to export the data for the model")
print("  * `data_analysis[['help']]()` to display this message again. ")
}
data_analysis[["help"]]()
